}
get_root = function(tree) {
# Returns the number of the root node of the given tree.
return(length(tree$tip.label) + 1)
}
is_tip = function(node, tree) {
# Returns TRUE if the given node is a tip, FALSE otherwise
return(node <= length(tree$tip.label))
}
initialize_description = function(tree, traits_at_tip) {
# This function creates a list whith two matrices and one vector.
#
# The first matrix is called traits and stores the values of the two traits at the nodes of
# the tree. Here we initialize this matrix with the given trait values at the tips and NA for
# the internal nodes. The values for the internal nodes have to be calculated in the
# function get_contrasts_in_subtree(). The row numbers correspond to the node numbers in the tree,
# i.e. for a tree with N tips the first N rows correspond to the tips, the last N-1 rows to the
# internal nodes.
#
# The second matrix is called normalized_contrasts and stores the values of the normalized contrasts
# for both traits at all nodes. The matrix will be filled out in the function
# get_contrasts_in_subtree(). Again, the row numbers correspond to the node numbers allocated in tree.
# As contrasts are only calculated at the internal nodes, the first N rows of this matrix will stay
# undefined, i.e. NA, as set here.
#
# The third object in the list is a vector that holds the corrected branch lenghts which will be
# calculated in the function get_contrasts_in_subtree(). It is initialized with the original branch lengths.
# The branches are ordered by the node which they lead to, e.g. branch_lengths[3] will give the branch that
# leads to node 3. The branch leading to the root will always be NA. Bear in mind that if you implement the
# tree walikng correctly, you will only need this data structure to compute all the corrected branch lengths,
# you do not need to store the uncorrected values separately.
number_of_tips = length(tree$tip.label)
# initialize the trait_matrix
trait_matrix = matrix(NA, nrow = 2 * number_of_tips - 1, ncol = 2,
dimnames = list(1:(2 * number_of_tips - 1),
c("value_of_trait1", "value_of_trait2")))
# fill in the known trait values
trait_matrix[1:length(tree$tip.label), ] = cbind(as.numeric(traits_at_tip$trait1[tree$tip.label]),
as.numeric(traits_at_tip$trait2[tree$tip.label]))
# initialize the normalized_contrasts matrix
contrast_matrix = matrix(NA, nrow = 2 * number_of_tips - 1, ncol = 2,
dimnames = list(1:(2 * number_of_tips - 1),
c("normalized_contrast_trait1", "normalized_contrast_trait2")))
# initialize the branch lengths
branch_lengths = c(tree$edge.length, NA)[order(c(tree$edge[, 2], length(tree$tip) + 1))]
# Return the three objects in one list
return(list(traits = trait_matrix, normalized_contrasts = contrast_matrix, corrected_branch_lengths = branch_lengths))
}
plot_data_and_regression = function(tree, description, summary_linear_regression) {
# This function displays two plots:
# On the left side the raw data points and the linear regression on the raw data, and
# On the right side the contrast values and the linear regression on the contrasts.
# As input this function takes two lists that will be generated by the following functions:
#   description: a list as produced by get_contrasts_in_subtree
#   summary_linear_regression: a list of two vectors with named values corresponding to the slope, intercept, p.value and R2
#							   for the linear regression on respectively the raw data and the contrasts, as produced by get_trait_correlation
par(mfrow = c(1, 2))
raw = data.frame(description$traits[1:length(tree$tip.label), ])
plot(raw, pch = 16, main = "raw data")
x = seq(range(raw[, "value_of_trait1"])[1], range(raw[, "value_of_trait1"])[2], by = 0.01)
lines(x, summary_linear_regression$linear_regression_raw_data["slope"] * x +
summary_linear_regression$linear_regression_raw_data["intercept"],
col = "gray")
legend("bottomright", bty = "n", cex = 0.7,
legend = paste0(names(summary_linear_regression$linear_regression_raw_data),
"=", signif(summary_linear_regression$linear_regression_raw_data, 3), 4))
cont = data.frame(description$normalized_contrasts[(length(tree$tip.label) + 1):(2 * length(tree$tip.label) - 1), ])
plot(cont, pch = 17, main = "contrasts")
x = seq(range(cont[, "normalized_contrast_trait1"])[1], range(cont[, "normalized_contrast_trait1"])[2], by = 0.01)
lines(x, summary_linear_regression$linear_regression_contrasts["slope"] * x +
summary_linear_regression$linear_regression_contrasts["intercept"],
col = "gray")
legend("bottomright", bty = "n", cex = 0.7,
legend = paste0(names(summary_linear_regression$linear_regression_contrasts),
"=", signif(summary_linear_regression$linear_regression_contrasts, 3), 4))
}
#########################################################
######    Code above this should not be changed   #######
######    or deleted.                             #######
#########################################################
linear_regression = function(values1, values2) {
# Perform a simple linear regression on two sets of given values to evaluate the possible correlation between them.
# The regression is approximated by the intercept alpha and the slope beta, values2 = alpha + beta*values1.
# The input values should be presented as vectors, in the same order:
# i.e. if the position i in values1 represents the value of trait or contrast at a certain node n, the same position i in values2
# should represent the value for the other trait or contrast at the same node n.
#   values1: first ordered vector of values
#   values2: second ordered vector of values
s<-summary(lm(y~x, data.frame(x = values1,y = values2)))
slope<-s$coefficients[2,1]
intercept<-s$coefficients[1,1]
p.value<-s$coefficients[2,4]
R2<-s$r.squared
# Return a vector with named values that summarizes the linear regression result.
#   slope: the slope of the linear regression line (beta)
#   intercept: the intercept of the linear regression line (alpha)
#   p.value: p-value, the level of significance of the correlation.
#   R2: R squared, the measure of how close the data are to the fitted regression line.
return(c(slope = slope, intercept = intercept, p.value = p.value, R2 = R2))
}
calculate_trait_at_internal_node = function(trait_child1, trait_child2, branch_length_to_child1, branch_length_to_child2) {
# Calculate the trait value at an internal node given the values of this trait at the
# two child nodes and the branch lengths connecting these child nodes to the parent node.
#   trait_child1: trait value at first child
#   trait_child2: trait value at second child
#   branch_length_to_child1: branch length leading to first child
#   branch_length_to_child2: branch length leading to second child
trait_at_internal_node<-(trait_child1*branch_length_to_child2+trait_child2*branch_length_to_child1)/(branch_length_to_child1+branch_length_to_child2)
# Return the estimated value of the trait at the internal node.
return(trait_at_internal_node)
}
calculate_contrast = function(trait_child1, trait_child2, branch_length_to_child1, branch_length_to_child2) {
# Calculate the normalized contrast at a given node given the values of a trait at the two child nodes
# and the branch lengths connecting these child nodes to the parent node.
# trait_child1: trait value at first child
# trait_child2: trait value at second child
# branch_length_to_child1: branch length leading to first child
# branch_length_to_child2: branch length leading to second child
contrast<-(trait_child1-trait_child2)/sqrt(branch_length_to_child1+branch_length_to_child2)
# Return the numerical value of the normalized contrast.
return(contrast)
}
calculate_corrected_branch_length = function(node, child1, child2, corrected_branch_lengths) {
# Calculate the corrected branch length leading to the given node.
#   node: the node at the end of the branch to be corrected
#   child1: the first child of the given node
#   child2: the second child of the given node
#   corrected_branch_lengths: the current vector of corrected branch lengths, where all branches
#                             below the given node have already been corrected
corrected_length<-corrected_branch_lengths[child1]*corrected_branch_lengths[child2]/(corrected_branch_lengths[child1]+corrected_branch_lengths[child2])+corrected_branch_lengths[node]
# Return the numeric value of corrected branch lengths
return(corrected_length)
}
calculate_trait_and_contrast = function(child1, child2, traits, corrected_branch_lengths) {
# Calculate the trait value and the normalized contrast value at a node given the indices of the node children.
#   child1: the first child of a given node
#   child2: the second child of a given node
#   traits: a vector containing trait values for all nodes
#   corrected_branch_lengths: the current vector of corrected branch lengths, where all branches
#                             below the node in question have already been corrected
trait_value<-calculate_trait_at_internal_node(traits[child1],traits[child2],corrected_branch_lengths[child1],corrected_branch_lengths[child2])
contrast<-calculate_contrast(traits[child1],traits[child2],corrected_branch_lengths[child1],corrected_branch_lengths[child2])
# Return the trait value and the normalized contrast value at the given node.
#   trait_value: the numerical value for the trait at given node
#   contrast: the numerical value for the contrast at given node
return(list(trait_value = trait_value, contrast = contrast))
}
get_contrasts_in_subtree = function(node, tree, description) {
# Calculate the normalized independent contrasts, trait values, and corrected branch lengths
# for the subtree that stems from the given node.
#   node: the node for which the contrasts should be calculated
#   tree: the tree encoded in an object of class phylo
# 	description: a list containing 3 entries:
#				 a matrix with the current trait values at all nodes (including tips) in the tree (value or NA)
#				 a matrix with the current contrasts at the internal nodes (value or NA), and
#				 a vector with the corrected branch lengths.
#				 This list is initialized by the provided function initialize_description().
# If the node is a tip, return the same description.
# Otherwise, get the child nodes of the given node and compute the corrected branch lengths, normalized contrasts and trait values
# for the child nodes, saving the updated description.
if(is_tip(node,tree)==TRUE){
updated_description<-description
}
# Update the branch length leading to the given node, save it in the description
# Compute the trait values and normalized contrasts for both traits, save the values in the description
if(is_tip(node,tree)==FALSE){
child1<-get_node_children(node,tree)$child1
child2<-get_node_children(node,tree)$child2
description<-get_contrasts_in_subtree (child1, tree, description)
description<-get_contrasts_in_subtree (child2, tree, description)
description$corrected_branch_lengths[node]<-calculate_corrected_branch_length(node,child1,child2,description$corrected_branch_lengths)
trait1_contrast1<-calculate_trait_and_contrast(child1,child2,description$traits[,'value_of_trait1'],description$corrected_branch_lengths)
trait2_contrast2<-calculate_trait_and_contrast(child1,child2,description$traits[,'value_of_trait2'],description$corrected_branch_lengths)
description$traits[node,'value_of_trait1']<-trait1_contrast1$trait_value
description$traits[node,'value_of_trait2']<-trait2_contrast2$trait_value
description$normalized_contrasts[node,'normalized_contrast_trait1']<-trait1_contrast1$contrast
description$normalized_contrasts[node,'normalized_contrast_trait2']<-trait2_contrast2$contrast
updated_description<-description
}
# Return a list with updated trait values, normalized contrasts, and corrected branch lenghts.
#   updated_description: list with structure as defined in the initialize_description() function.
return(updated_description)
}
get_trait_correlation = function(newick_tree, traits_at_tip) {
# Compute the normalized contrasts for the whole tree and determine whether there is a correlation between
# the contrasts.
#   newick_tree: the tree in newick text format
#   traits_at_tips: a list of two vectors that represent the two trait values observed for the
#                   individuals at the tips.
# Transform the tree from text format to an object of the phylo class
tree = read.tree(text = newick_tree)
# Reorder the tree for easier traversing
tree = reorder(tree, order = "cladewise")
# Initialize the list of traits, contrasts and branch lengths
initial_description<-initialize_description(tree, traits_at_tip)
# Calculate the new trait values at all the nodes in the tree, normalized contrasts at the internal nodes and the
# corrected branch lengths, starting at the root of the tree.
root<-get_root(tree)
updated_description<-get_contrasts_in_subtree(root,tree,initial_description)
# Perform linear regression on the traits at the tips and get the slope, intercept, P-value, and R2-value
raw_data_regression<-linear_regression(unlist(traits_at_tip[1],use.names = FALSE),unlist(traits_at_tip[2],use.names = FALSE))
# Perform linear regression on the normalized contrasts and get the slope, intercept, P-value, and R2-value
contrasts_regression<-linear_regression(updated_description$normalized_contrasts[,'normalized_contrast_trait1'],updated_description$normalized_contrasts[,'normalized_contrast_trait2'])
# Plot the two linear regression results
summary_linear_regression <- list(linear_regression_raw_data = raw_data_regression,
linear_regression_contrasts = contrasts_regression)
plot_data_and_regression(tree, updated_description, summary_linear_regression)
return(summary_linear_regression)
}
test_trait_correlation = function() {
newick_tree = "(unicorn:15,(orangutan:13,(gorilla:10.25,(human:5.5,chimp:5.5):4.75):2.75):2);"
traits_at_tip = list(trait1 = c(unicorn=5, orangutan=2, gorilla=9, human=1, chimp=4),
trait2 = c(unicorn=6, orangutan=5, gorilla=15, human=3, chimp=9))
print(get_trait_correlation(newick_tree, traits_at_tip))
}
#test_trait_correlation()
View(test_trait_correlation)
BiocManager::install(c("rtracklayer", "GenomicRanges"))
BiocManager::valid()
BiocManager::available("TxDb.Hsapiens")
browseVignettes("simpleSingleCell")
library("rtracklayer")
library("GenomicRanges")
install.packages("rtracklayer")
updateR()
install.packages("installr"); library(installr)
install.packages("installr")
library(devtools)
install.packages("devtools")
library(devtools)
library("devtools")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rtracklayer")
if (!"BiocManager" %in% rownames(intalled.packages()))
install.packages("BiocManager", repos="https://cran.r-project.org")
if (!"BiocManager" %in% rownames(intalled.packages()))
install.packages("BiocManager", repos="https://cran.r-project.org")
install.packages(c("ggplot2", "tibble"))
library("ggplot2")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("rtracklayer")
library('rtracklayer')
# GEOquery
library(GEOquery)
gse = getGEO("GSE103512")[[1]]
# convert from ExpressionSet to SummarizedExperiment
library(SummarizedExperiment)
se = as(gse,'SummarisedExperiment')
se = as(gse,'SummarizedExperiment')
View(se)
# examine variables of interest
with(colData(se),table(`cancer.type.ch1`,`normal.ch1`))
# perform multidimensional scaling
# make a data frame
mdsvals = cmdscale(dist(t(dat)))
# filter gene expression by variance to find most informative genes
sds = apply(assay(se,'exprs'),1,sd)
dat = assay(se,'exprs')[order(sds,decreasing = TRUE)[1:500],]
# perform multidimensional scaling
# make a data frame
mdsvals = cmdscale(dist(t(dat)))
mdsvals = as.data.frame(mdsvals)
mdsvals$Type=factor(colData(se)[,'cancer.type.ch1'])
mdsvals$Normal = factor(colData(se)[,'normal.ch1'])
head(mdsvals)
library(ggplot2)
ggplot(mdsvals, aes(x=V1,y=V2,shape=Normal,color=Type)) +
geom_point( alpha=0.6) + theme(text=element_text(size = 18))
# GenomicDataCommons
library(GenomicDataCommons)
# check network connectivity
GenomicDataCommons::status()
#find data
ge_manifest = files() %>%
filter( ~ cases.project.project_id == 'TCGA-OV' &
type == 'gene_expression' &
analysis.workflow_type == 'HTSeq - Counts') %>%
manifest()
ge_manifest = files() %>%
filter( ~ cases.project.project_id == 'TCGA-OV' &
type == 'gene_expression' &
analysis.workflow_type == 'HTSeq - Counts') %>%
manifest()
# download data
fnames = lapply(ge_manifest$id[1:20],gdcdata)
expands = c("diagnoses","annotations",
"demographic","exposures")
projResults = projects() %>%
results(size=10)
str(projResults,list.len=5)
names(projResults)
# Querying metadata
# creating a query
pquery = projects()
str(query)
str(pquery)
# retrieving results
pcount = count(pquery)
pcount = pquery %>% count()
pcount
# result() fetch actual results
presults = pquery %>% results()
str(presults)
length(ids(presults))
presults = pquery %>% results_all()
# results_all() fetch all the available results given a query
presults = pquery %>% results_all()
length(ids(presults))
length(ids(presults)) == count(pquery)
# fields and values
default_fields('files')
length(available_fields('files'))
head(available_fields('files'))
qcases = cases()
qcases$fields
qcases = cases() %>% GenomicDataCommons::select(available_fields('cases'))
head(qcases$fields)
# facets and aggregation
res = files() %>% facet(c('type','data_type')) %>% aggregations()
res$type
# filtering
qfiles = files()
qfiles %>% count()
# filter file results to only "gene_expression" files
qfiles = files() %>% filter(~ type == 'gene_expression')
str(get_filter(qfiles))
# create a filter based on the project
grep('pro',available_fields('files'),value=TRUE)
files() %>% facet('cases.project.project_id') %>% aggregations()
qfiles = files() %>%
filter( ~ cases.project.project_id == 'TCGA-OV' & type == 'gene_expression')
str(get_filter(qfiles))
qfiles %>% count()
# generate a manifest for buld downloads
manifest_df = qfiles %>% manifest()
head(manifest_df)
# Datafile access and download
fnames = gdcdata(manifest_df$id[1:2],progress = FALSE)
BiocManager::install('seandavi/SRAdbV2')
# Sequence Read Archive
library(SRAdbV2)
# create a new instance of Omicidx class
oidx = Omicidx$new()
query=paste(
paste0('sample_taxon_id:', 10116),
'AND experiment_library_strategy:"rna seq"',
'AND experiment_library_source:transcriptomic',
'AND experiment_platform:illumina')
z = oidx$search(q=query,entity='full',size=100L)
# fetching results
s = z$scroll()
s
# collating entire result sets
res = s$collate(limit = 1000)
head(res)
# To resus a Scroller, we need reset.
s$reset()
s
# yielding chunks
j = 0
while(s$fetched < 500) {
res = s$yield()
# do something interesting with `res` here if you like
j = j + 1
message(sprintf('total of %d fetched records, loop iteration # %d', s$fetched, j))
}
library(TCGAbiolinks)
library(SummarizedExperiment)
query <- GDCquery(project = "TCGA-ACC",
data.category = "Gene expression",
data.type = "Gene expression quantification",
platform = "Illumina HiSeq",
file.type  = "normalized_results",
experimental.strategy = "RNA-Seq",
legacy = TRUE)
gdcdir <- file.path("Waldron_PublicData", "GDCdata")
GDCdownload(query, method = "api", files.per.chunk = 10,
directory = gdcdir)
ACCse <- GDCprepare(query, directory = gdcdir)
ACCse
# curatedTCGAData: Curated Data From The Cancer Genome Atlas as MultiAssayExperiment Objects
library(curatedTCGAData)
library(MultiAssayExperiment)
# By default, the curatedTCGAData() function will only show available datasets, and not download anything.
curatedTCGAData(diseaseCode = "*", assays = "*")
curatedTCGAData(diseaseCode = "ACC")
##  recount: Reproducible RNA-seq Analysis Using recount2
library(recount)
project_info <- abstract_search('GSE32465')
## curated*Data packages for standardized cancer transcriptomes
# microbiome data
# curatedMetagenomicData: Curated and processed metagenomic data through ExperimentHub
library(curatedMetagenomicData)
View(data.frame(combined_metadata))
#  HMP16SData: 16S rRNA Sequencing Data from the Human Microbiome Project
suppressPackageStartupMessages(library(HMP16SData))
V13()
## Pharmacogenomics
library(PharmacoGx)
# install RNAseq123 workflow
source("https://bioconductor.org/biocLite.R")
biocLite("RNAseq123")
suppressPackageStartupMessages({
library(limma)
library(Glimma)
library(edgeR)
library(Mus.musculus)
})
setwd("~/Desktop/bioinformatics-100-days/day6")
# Data packaging
dir.create("Law_RNAseq123")
setwd("Law_RNAseq123/")
setwd("Law_RNAseq123")
# Data packaging
dir.create("Law_RNAseq123")
setwd("Law_RNAseq123")
# download the relevant sequencing data
url <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&format=file"
utils::download.file(url, destfile="GSE63310_RAW.tar", mode="wb")
utils::untar("GSE63310_RAW.tar", exdir = ".")
files <- c("GSM1545535_10_6_5_11.txt", "GSM1545536_9_6_5_11.txt", "GSM1545538_purep53.txt",
"GSM1545539_JMS8-2.txt", "GSM1545540_JMS8-3.txt", "GSM1545541_JMS8-4.txt",
"GSM1545542_JMS8-5.txt", "GSM1545544_JMS9-P7c.txt", "GSM1545545_JMS9-P8c.txt")
for(i in paste(files, ".gz", sep=""))
R.utils::gunzip(i, overwrite=TRUE)
# reading in count-data
read.delim(file.path("Law_RNAseq123", files[1]), nrow=5)
# Data packaging
dir.create("Law_RNAseq123")
setwd("Law_RNAseq123")
setwd("~/Desktop/bioinformatics-100-days/day6")
# Data packaging
dir.create("Law_RNAseq123")
setwd("Law_RNAseq123")
url <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE63310&format=file"
utils::download.file(url, destfile="GSE63310_RAW.tar", mode="wb")
utils::untar("GSE63310_RAW.tar", exdir = ".")
files <- c("GSM1545535_10_6_5_11.txt", "GSM1545536_9_6_5_11.txt", "GSM1545538_purep53.txt",
"GSM1545539_JMS8-2.txt", "GSM1545540_JMS8-3.txt", "GSM1545541_JMS8-4.txt",
"GSM1545542_JMS8-5.txt", "GSM1545544_JMS9-P7c.txt", "GSM1545545_JMS9-P8c.txt")
for(i in paste(files, ".gz", sep=""))
R.utils::gunzip(i, overwrite=TRUE)
# reading in count-data
read.delim(file.path("Law_RNAseq123",files[1]), nrow=5)
getwd
getwd()d
getwd()
# reading in count-data
read.delim(file.path(files[1]), nrow=5)
# edgeR offers a convenient way to read the nine text files separately and combine them into a matrix of
## counts in one step
x <- readDGE(file.path(files),columns = c(1,3))
class(x)
dim(x)
# Organising sample information
samplenames <- substring(colnames(x), 12, nchar(colnames(x)))
samplenames
colnames(x) <- samplenames
group <- as.factor(c("LP","ML","Basal","Basal","ML","LP","Basal","ML","LP"))
x$samples$group <- group
lane <- as.factor((rep(c("L004","L006","L008"),c(3,4,2))))
x$samples$lane <- lane
x$samples
# Organising gene annotations
# second data frame named genes in the DGEList-object is used to store gene-level information associated with rows of
# the counts matrix
geneid <- rownames(x)
genes <- select(Mus.musculus, keys = gemeid, columns = c("SYMBOL", "TXCHROM"),keytype = 'ENTREZID')
genes <- select(Mus.musculus, keys = geneid, columns = c("SYMBOL", "TXCHROM"),keytype = 'ENTREZID')
head(genes)
# keep only the first occurence of each gene ID
genes <- genes[!duplicated(genes$ENTREZID)]
# keep only the first occurence of each gene ID
genes <- genes[!duplicated(genes$ENTREZID),]
x$genes <- genes
x
## Data pre-processing
# transformations from the raw-scale
cpm <- cpm(x)
lcpm <- cpm(x, log=TRUE)
# removing genes that are lowly expressed
table(rowSums(x$counts==0)==9)
# set the expression cutoff as 1 to separate expressed genes from unexpressed genes
keep.exprs <- rowSums(cpm>1)>=3
x <- x[keep.exprs,,keep.lib.sized = FALSE]
x <- x[keep.exprs,,keep.lib.sizes = FALSE]
dim(x)
library(RColorBrewer)
nsamples <- ncol(x)
col <- brewer.pal(nsamples, "Paired")
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")
lcpm <- cpm(x, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2,
main="", xlab="")
title(main="B. Filtered data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
den <- density(lcpm[,i])
lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")
